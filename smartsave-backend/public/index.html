<script>
/**
 * VAULT (Original UI) + Backend Storage Layer
 * - Keeps your original layout + features
 * - Uses backend for auth + transactions + budgets + recurring + metrics
 *
 * Endpoints used (from your backend):
 *  - POST   /api/auth/signup, /api/auth/login  :contentReference[oaicite:6]{index=6}
 *  - GET    /api/dashboard/metrics            :contentReference[oaicite:7]{index=7}
 *  - GET    /api/transactions                 :contentReference[oaicite:8]{index=8}
 *  - POST   /api/transactions                 :contentReference[oaicite:9]{index=9}
 *  - DELETE /api/transactions/:id             :contentReference[oaicite:10]{index=10}
 *  - GET/POST /api/budget (+ /category)       :contentReference[oaicite:11]{index=11}
 *  - GET/POST/DELETE /api/recurring           :contentReference[oaicite:12]{index=12}
 */

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CONFIG
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const API_URL = 'https://smartsave-backend-j3f0.onrender.com/api';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  AUTH STATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let token = localStorage.getItem('token') || null;

// We store the user object locally because backend does not expose a "me" endpoint in the files you shared.
// This lets refresh still show name/initial without re-login.
let persistedUser = null;
try { persistedUser = JSON.parse(localStorage.getItem('user') || 'null'); } catch { persistedUser = null; }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  ORIGINAL STATE (keep as your original)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const state = {
  user: null,
  transactions: [],
  recurringExpenses: [],
  availableBalance: 0,
  savingsBalance: 0,
  totalIncome: 0,
  budgetSpent: 0,
  monthlyBudget: 0,
  budgetsByMonth: {}, // { "2025-01": { budget: 1000, spent: 250 }, ... }
  goal: { amount:0, deadline:null, name:'', description:'', icon:'fa-plane', emoji:'âœˆï¸' },
  catBudgets: {},
  currentType: 'expense',
  lang: 'en',
  currency: 'USD',
  streak: 0,
  dateFilter: { start:null, end:null },
  alertShown: { eighty:false, breached:false },
  txToDelete: null
};

const CURRENCIES = {
  USD:{ sym:'$', locale:'en-US' },
  EUR:{ sym:'â‚¬', locale:'de-DE' },
  GBP:{ sym:'Â£', locale:'en-GB' },
  BRL:{ sym:'R$', locale:'pt-BR' }
};

const CATS = {
  food:          { color:'#f87171', label:'Food & Dining',  icon:'fa-utensils',    daily:true },
  shopping:      { color:'#60a5fa', label:'Shopping',       icon:'fa-shopping-bag',daily:true },
  transport:     { color:'#34d399', label:'Transport',      icon:'fa-bus',         daily:true },
  entertainment: { color:'#a78bfa', label:'Entertainment',  icon:'fa-film',        daily:true },
  bills:         { color:'#fbbf24', label:'Bills',          icon:'fa-bolt',        daily:false }, // amortized
  others:        { color:'#8a95a3', label:'Others',         icon:'fa-receipt',     daily:true }
};

const REC_CATS = {
  housing:       { color:'#c8922a', label:'Housing',        icon:'ğŸ ' },
  insurance:     { color:'#60a5fa', label:'Insurance',      icon:'ğŸ›¡ï¸' },
  loans:         { color:'#f87171', label:'Loans',          icon:'ğŸ’³' },
  subscriptions: { color:'#a78bfa', label:'Subscriptions',  icon:'ğŸ“±' },
  utilities:     { color:'#fbbf24', label:'Utilities',      icon:'ğŸ’¡' },
  transport:     { color:'#34d399', label:'Transport',      icon:'ğŸš—' },
  health:        { color:'#f0a0a0', label:'Health',         icon:'ğŸ¥' },
  others:        { color:'#8a95a3', label:'Others',         icon:'ğŸ“¦' }
};

// If your original file had these globals, keep them:
let chart = null;
let currentPage = 'dashboard';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  API HELPER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function apiCall(endpoint, method='GET', body=null) {
  const headers = { 'Content-Type': 'application/json' };
  if (token) headers['Authorization'] = `Bearer ${token}`;

  const res = await fetch(`${API_URL}${endpoint}`, {
    method,
    headers,
    body: body ? JSON.stringify(body) : null
  });

  // Handle auth expiry
  if (res.status === 401) {
    logout();
    throw new Error('Unauthorized');
  }

  const data = await res.json().catch(() => ({}));
  if (!res.ok) {
    const msg = data?.error || `Request failed (${res.status})`;
    throw new Error(msg);
  }
  return data;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  AUTH (UI tabs remain same layout)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let authMode = 'login';
function switchTab(mode) {
  authMode = mode;
  document.getElementById('tab-login').classList.toggle('active', mode==='login');
  document.getElementById('tab-signup').classList.toggle('active', mode==='signup');
  document.getElementById('name-group').style.display = mode==='signup' ? 'block' : 'none';
  document.getElementById('auth-submit').textContent = mode==='login' ? 'Login' : 'Create Account';
}

async function handleAuth(e) {
  e.preventDefault();

  const email = document.getElementById('inp-email').value.trim();
  const password = document.getElementById('inp-pwd').value;
  const name = (document.getElementById('inp-name').value || '').trim();

  try {
    const endpoint = authMode === 'login' ? '/auth/login' : '/auth/signup';
    const payload = authMode === 'login'
      ? { email, password }
      : { name, email, password };

    const data = await apiCall(endpoint, 'POST', payload);

    // Backend returns { token, user } :contentReference[oaicite:13]{index=13}
    token = data.token;
    localStorage.setItem('token', token);
    localStorage.setItem('user', JSON.stringify(data.user));

    state.user = data.user;

    await bootApp(); // will hydrate from API
  } catch (err) {
    console.error(err);
    toast('Auth Error', err.message || 'Network error. Please try again.', 'error');
  }
}

function logout() {
  localStorage.removeItem('token');
  localStorage.removeItem('user');
  token = null;
  state.user = null;
  location.reload();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  BOOT (same UI, just loads from API)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function bootApp() {
  document.getElementById('auth-screen').style.display = 'none';
  document.getElementById('app').classList.add('visible');

  // Restore name/initial from user
  const u = state.user || persistedUser || { name: 'Saver' };
  state.user = u;

  document.getElementById('display-name').textContent = u.name || 'Saver';
  document.getElementById('user-initial').textContent = (u.name || 'S')[0].toUpperCase();

  const h = new Date().getHours();
  document.getElementById('time-greeting').textContent = h<12?'morning':h<17?'afternoon':'evening';
  document.getElementById('today-date').textContent = new Date().toLocaleDateString('en-US',{
    weekday:'long',month:'long',day:'numeric',year:'numeric'
  });

  // Load local-only preferences (goal, currency, etc.)
  loadLocalPrefsOnly();

  // Hydrate â€œrealâ€ app data from backend
  await hydrateFromBackend();

  // Keep your original init calls
  checkNewMonth?.();
  initDates?.();
  applyCurrencySymbols?.();

  updateAll?.();
  updateRecurringPage?.();
  updatePlanningPage?.();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  LOCAL PREFS (goal/settings/currency) - kept local
//  because your backend routes do not persist these yet.
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function loadLocalPrefsOnly() {
  const raw = localStorage.getItem('vault_prefs');
  if (!raw) return;
  try {
    const d = JSON.parse(raw);
    state.goal = d.goal || state.goal;
    state.catBudgets = d.catBudgets || {};
    state.lang = d.lang || 'en';
    state.currency = d.currency || 'USD';
  } catch {}
}

function saveLocalPrefsOnly() {
  localStorage.setItem('vault_prefs', JSON.stringify({
    goal: state.goal,
    catBudgets: state.catBudgets,
    lang: state.lang,
    currency: state.currency
  }));
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  HYDRATE FROM BACKEND
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function hydrateFromBackend() {
  // 1) Metrics (balances, streak)
  const metrics = await apiCall('/dashboard/metrics', 'GET'); // :contentReference[oaicite:14]{index=14}
  state.availableBalance = metrics.available || 0;
  state.savingsBalance   = metrics.savings || 0;
  state.totalIncome      = metrics.totalIncome || 0;
  state.streak           = metrics.streak || 0;
  state.monthlyBudget    = metrics.budget || 0;
  state.budgetSpent      = metrics.spent || 0;

  // 2) Budget details (budgetsByMonth)
  try {
    const bud = await apiCall('/budget', 'GET'); // :contentReference[oaicite:15]{index=15}
    state.monthlyBudget = bud.monthlyBudget || state.monthlyBudget;
    state.budgetsByMonth = bud.budgetsByMonth || state.budgetsByMonth || {};
  } catch (e) {
    // not fatal
    console.warn('Budget hydrate skipped:', e.message);
  }

  // 3) Transactions
  // Your transactions route sometimes returns {transactions: []} (fixed version) :contentReference[oaicite:16]{index=16}
  // but some older route versions returned [] directly. We support both.
  const txRes = await apiCall('/transactions', 'GET');
  const txs = Array.isArray(txRes) ? txRes : (txRes.transactions || []);
  state.transactions = txs.map(t => ({
    id: t._id || t.id,                 // normalize
    merchant: t.merchant || 'â€”',
    amount: Number(t.amount || 0),
    category: t.category || null,
    date: t.date,
    type: t.type
  })).sort((a,b) => (b.date||'').localeCompare(a.date||''));

  // 4) Recurring
  const recRes = await apiCall('/recurring', 'GET'); // :contentReference[oaicite:17]{index=17}
  state.recurringExpenses = (Array.isArray(recRes) ? recRes : []).map(r => ({
    id: r._id || r.id,
    name: r.name,
    category: r.category || 'others',
    amount: Number(r.amount || 0),
    frequency: r.frequency || 'monthly',
    startDate: r.startDate,
    endDate: r.endDate || null,
    autoRecord: false // backend model doesnâ€™t store this yet
  }));

  // Ensure streak UI appears
  updateStreakUI?.();

  // If your original code depended on recalculation:
  if (typeof recalculateMonthlySpent === 'function') {
    recalculateMonthlySpent();
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  TRANSACTIONS (same UI, but backend write)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function setType(type) {
  state.currentType = type;
  document.getElementById('btn-expense').className = 'type-btn'+(type==='expense'?' active-expense':'');
  document.getElementById('btn-income').className = 'type-btn'+(type==='income'?' active-income':'');
  document.getElementById('btn-save').className = 'type-btn'+(type==='save'?' active-save':'');
  document.getElementById('cat-group').style.display = type==='expense' ? 'block' : 'none';
  const labels = { expense:'Record Expense', income:'Record Income', save:'Move to Savings' };
  document.getElementById('btn-add-label').textContent = labels[type];
}

async function addTx() {
  const amount = parseFloat(document.getElementById('tx-amount').value);
  const cat = document.getElementById('tx-cat').value;
  const dateVal = document.getElementById('tx-date').value;

  if (!amount || amount <= 0) { toast('Invalid Amount','Enter a positive number','error'); return; }
  if (state.currentType==='save' && amount > state.availableBalance) {
    toast('Insufficient Balance',`Only ${fmt(state.availableBalance)} available`,'error');
    return;
  }

  const merchant =
    state.currentType==='income' ? 'Income' :
    state.currentType==='save'   ? 'Saved to Goal' :
    (CATS[cat]?.label || 'Expense');

  try {
    const payload = {
      merchant,
      amount,
      category: state.currentType==='expense' ? cat : null,
      date: dateVal || new Date().toISOString().split('T')[0],
      type: state.currentType
    };

    const res = await apiCall('/transactions', 'POST', payload); // :contentReference[oaicite:18]{index=18}

    const t = res.transaction;
    const updatedUser = res.user;

    // Insert tx into local state for UI
    state.transactions.unshift({
      id: t._id || t.id,
      merchant: t.merchant,
      amount: Number(t.amount),
      category: t.category,
      date: t.date,
      type: t.type
    });

    // Update balances from backend truth
    state.availableBalance = updatedUser.availableBalance ?? state.availableBalance;
    state.savingsBalance   = updatedUser.savingsBalance ?? state.savingsBalance;
    state.totalIncome      = updatedUser.totalIncome ?? state.totalIncome;
    state.streak           = updatedUser.streak ?? state.streak;
    state.budgetsByMonth   = updatedUser.budgetsByMonth ?? state.budgetsByMonth;

    // Keep budgetSpent consistent for current month if your original helpers exist
    if (typeof getCurrentMonthBudget === 'function') {
      state.budgetSpent = getCurrentMonthBudget().spent;
    }

    // Clear inputs (keep original behavior)
    document.getElementById('tx-amount').value = '';
    toast('Added', `${merchant} â€” ${fmt(amount)}`, 'success');

    updateAll?.();
    updateRecurringPage?.();
    updatePlanningPage?.();
    runAI?.();

  } catch (err) {
    console.error(err);
    toast('Error', err.message || 'Failed to add transaction', 'error');
  }
}

function openDeleteModal(id) {
  state.txToDelete = id;
  openModal('modal-delete');
}

async function confirmDelete() {
  const id = state.txToDelete;
  if (!id) { closeModal('modal-delete'); return; }

  try {
    const res = await apiCall(`/transactions/${id}`, 'DELETE'); // :contentReference[oaicite:19]{index=19}

    // Remove from local list
    state.transactions = state.transactions.filter(t => String(t.id) !== String(id));

    // Update balances from backend truth
    if (res.user) {
      state.availableBalance = res.user.availableBalance ?? state.availableBalance;
      state.savingsBalance   = res.user.savingsBalance ?? state.savingsBalance;
      state.totalIncome      = res.user.totalIncome ?? state.totalIncome;
      state.budgetsByMonth   = res.user.budgetsByMonth ?? state.budgetsByMonth;
      if (typeof getCurrentMonthBudget === 'function') {
        state.budgetSpent = getCurrentMonthBudget().spent;
      }
    }

    closeModal('modal-delete');
    toast('Deleted','Transaction removed','success');

    updateAll?.();
    updatePlanningPage?.();
    runAI?.();
  } catch (err) {
    console.error(err);
    toast('Error', err.message || 'Failed to delete', 'error');
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  BUDGET (backend write)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function setMonthlyBudget(amount) {
  const val = Number(amount);
  if (!val || val <= 0) { toast('Error', 'Invalid budget amount', 'error'); return; }

  try {
    const res = await apiCall('/budget', 'POST', { amount: val }); // :contentReference[oaicite:20]{index=20}
    state.monthlyBudget = res.monthlyBudget ?? val;
    state.budgetsByMonth = res.budgetsByMonth ?? state.budgetsByMonth;

    toast('Budget Updated', `Monthly budget set to ${fmt(state.monthlyBudget)}`, 'success');
    updateAll?.();
    updatePlanningPage?.();
  } catch (err) {
    console.error(err);
    toast('Error', err.message || 'Failed to set budget', 'error');
  }
}

// If your original UI calls openBudgetModal/saveBudgetFromModal,
// keep those and just call setMonthlyBudget(...) inside them.

// Category budgets remain local unless you want to persist them too.
async function setCategoryBudget(category, amount) {
  // You DO have POST /api/budget/category :contentReference[oaicite:21]{index=21}
  // But the backend doesnâ€™t provide GET to load catBudgets across devices in the code shared.
  // So weâ€™ll store locally AND optionally push to backend.
  state.catBudgets[category] = Number(amount || 0);
  saveLocalPrefsOnly();

  try {
    await apiCall('/budget/category', 'POST', { category, amount: Number(amount || 0) });
  } catch (e) {
    console.warn('Category budget backend save failed (kept local):', e.message);
  }

  updateAll?.();
  updatePlanningPage?.();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  RECURRING (backend write)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function addRecurringBackend(rec) {
  // Backend expects {name, amount, frequency, category, startDate, endDate} :contentReference[oaicite:22]{index=22}
  const created = await apiCall('/recurring', 'POST', {
    name: rec.name,
    amount: rec.amount,
    frequency: rec.frequency,
    category: rec.category,
    startDate: rec.startDate,
    endDate: rec.endDate
  });

  return {
    ...rec,
    id: created._id || created.id
  };
}

async function deleteRecurringBackend(id) {
  await apiCall(`/recurring/${id}`, 'DELETE'); // :contentReference[oaicite:23]{index=23}
}

// If your original addRecurring() exists, keep UI the same but change the â€œpush to stateâ€ part:
async function addRecurring() {
  const name = document.getElementById('rec-name').value.trim();
  const cat = document.getElementById('rec-cat').value;
  const amount = parseFloat(document.getElementById('rec-amount').value);
  const freq = document.getElementById('rec-freq').value;
  const startDate = document.getElementById('rec-start').value;
  const endDate = document.getElementById('rec-end').value;
  const autoRecord = document.getElementById('rec-auto-toggle').classList.contains('on');

  if (!name) { toast('Error','Enter a name','error'); return; }
  if (!amount||amount<=0) { toast('Error','Enter valid amount','error'); return; }
  if (!startDate) { toast('Error','Select start date','error'); return; }

  try {
    const localRec = { id: null, name, category:cat, amount, frequency:freq, startDate, endDate:endDate||null, autoRecord };
    const saved = await addRecurringBackend(localRec);

    state.recurringExpenses.push(saved);

    closeModal('modal-recurring');
    toast('Recurring Added', `${name} â€” ${fmt(toMonthlyAmount(amount,freq))}/mo`, 'success');

    updateRecurringPage?.();
    updateDailyBanner?.();
    updateAll?.();
  } catch (err) {
    console.error(err);
    toast('Error', err.message || 'Failed to add recurring', 'error');
  }
}

async function deleteRecurring(id) {
  try {
    await deleteRecurringBackend(id);
  } catch (e) {
    console.warn('Recurring delete backend failed:', e.message);
  }
  state.recurringExpenses = state.recurringExpenses.filter(r => String(r.id) !== String(id));
  toast('Removed','Recurring expense deleted','info');
  updateRecurringPage?.();
  updateDailyBanner?.();
  updateAll?.();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  UI NAV (keep original)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function showPage(page) {
  currentPage = page;
  document.querySelectorAll('.page-section').forEach(s => s.classList.remove('active'));
  document.getElementById('page-'+page)?.classList.add('active');

  document.querySelectorAll('.nav-tab').forEach((t,i) => {
    const pages = ['dashboard','recurring','planning'];
    t.classList.toggle('active', pages[i] === page);
  });

  if (page === 'recurring') updateRecurringPage?.();
  if (page === 'planning') updatePlanningPage?.();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FORMATTERS (use your originals if present)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function fmt(n) {
  const cur = CURRENCIES[state.currency] || CURRENCIES.USD;
  return new Intl.NumberFormat(cur.locale, { style:'currency', currency: state.currency }).format(Number(n||0));
}

// If your original file defines toMonthlyAmount/getMonthKey/etc, keep them.
// If not, minimal fallback:
function toMonthlyAmount(amount, freq) {
  const a = Number(amount||0);
  if (freq === 'weekly') return a * 4;
  if (freq === 'yearly') return a / 12;
  return a; // monthly default
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  STREAK, MODAL, TOAST, CONFETTI
//  (copied from your original snippets)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function updateStreakUI() {
  if (state.streak>0) {
    document.getElementById('streak-display').style.display='flex';
    document.getElementById('streak-num').textContent=state.streak;
  }
}
function openModal(id) { document.getElementById(id)?.classList.add('open'); }
function closeModal(id) { document.getElementById(id)?.classList.remove('open'); }

function toast(title,msg,type='success') {
  const c=document.getElementById('toast-container');
  if (!c) { alert(`${title}: ${msg}`); return; }
  const el=document.createElement('div');
  el.className=`toast ${type}`;
  el.innerHTML=`<div class="toast-dot"></div><div class="toast-body"><div class="toast-title">${title}</div><div class="toast-msg">${msg}</div></div>`;
  c.appendChild(el);
  const delay=type==='error'?5000:3000;
  setTimeout(()=>{ el.classList.add('fade-out'); setTimeout(()=>el.remove(),300); },delay);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  AUTO-BOOT ON REFRESH (if token exists)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
(async function init() {
  // Keep your original default auth tab
  switchTab('login');

  // If already logged in, boot immediately
  if (token && persistedUser) {
    state.user = persistedUser;
    try {
      await bootApp();
    } catch (e) {
      console.warn('Auto-boot failed:', e.message);
      // fallback to auth screen
      document.getElementById('auth-screen').style.display = 'flex';
    }
  }
})();
</script>
